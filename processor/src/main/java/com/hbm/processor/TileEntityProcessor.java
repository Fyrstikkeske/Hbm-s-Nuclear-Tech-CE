package com.hbm.processor;

import com.google.auto.service.AutoService;
import com.hbm.interfaces.AutoRegisterTE;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

@AutoService(Processor.class)
@SupportedAnnotationTypes("com.hbm.interfaces.AutoRegisterTE")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class TileEntityProcessor extends AbstractProcessor {
    private final Map<String, String> tileEntitiesToRegister = new LinkedHashMap<>();
    private Filer filer;
    private Messager messager;
    private Elements elementUtils;
    private Types typeUtils;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        this.filer = processingEnv.getFiler();
        this.messager = processingEnv.getMessager();
        this.elementUtils = processingEnv.getElementUtils();
        this.typeUtils = processingEnv.getTypeUtils();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(AutoRegisterTE.class)) {
            if (!(element instanceof TypeElement)) {
                messager.printMessage(Diagnostic.Kind.ERROR, "Annotation @AutoRegisterTE can only be applied to classes.", element);
                continue;
            }
            TypeElement typeElement = (TypeElement) element;
            if (typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
                messager.printMessage(Diagnostic.Kind.WARNING, "Skipping abstract class for registration.", element);
                continue;
            }
            TypeElement tileEntityElement = elementUtils.getTypeElement("net.minecraft.tileentity.TileEntity");
            if (!typeUtils.isSubtype(typeElement.asType(), tileEntityElement.asType())) {
                messager.printMessage(Diagnostic.Kind.ERROR, "Class annotated with @AutoRegisterTE must extend net.minecraft.tileentity.TileEntity" +
                        ".", element);
                continue;
            }
            try {
                String qualifiedName = typeElement.getQualifiedName().toString();
                String simpleName = typeElement.getSimpleName().toString();
                AutoRegisterTE annotation = typeElement.getAnnotation(AutoRegisterTE.class);
                String registrationId = annotation.value();
                if (registrationId.trim().isEmpty()) registrationId = generateRegistrationId(simpleName);
                tileEntitiesToRegister.put(qualifiedName, registrationId);
            } catch (Exception e) {
                messager.printMessage(Diagnostic.Kind.ERROR, "Could not process @AutoRegisterTE annotation: " + e.getMessage(), element);
            }
        }
        if (roundEnv.processingOver() && !tileEntitiesToRegister.isEmpty()) {
            try {
                generateRegistrarFile();
            } catch (IOException e) {
                messager.printMessage(Diagnostic.Kind.ERROR, "Failed to generate TileEntity registrar file: " + e.getMessage());
            }
        }
        return true;
    }

    private void generateRegistrarFile() throws IOException {
        MethodSpec.Builder registerAllMethod = MethodSpec.methodBuilder("registerAll")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(void.class)
                .addJavadoc("Generated by HBM's annotation processor. Do not edit this file manually!");
        ClassName gameRegistry = ClassName.get("net.minecraftforge.fml.common.registry", "GameRegistry");
        ClassName resourceLocation = ClassName.get("net.minecraft.util", "ResourceLocation");
        ClassName refStrings = ClassName.get("com.hbm.lib", "RefStrings");
        for (Map.Entry<String, String> entry : tileEntitiesToRegister.entrySet()) {
            String classFqn = entry.getKey();
            String regId = entry.getValue();
            ClassName tileEntityClass = ClassName.bestGuess(classFqn);
            registerAllMethod.addStatement(
                    "$T.registerTileEntity($T.class, new $T($T.MODID, $S))",
                    gameRegistry, tileEntityClass, resourceLocation, refStrings, regId);
        }
        TypeSpec generatedRegistrar = TypeSpec.classBuilder("GeneratedTERegistrar")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(registerAllMethod.build())
                .build();
        JavaFile javaFile = JavaFile.builder("com.hbm.generated", generatedRegistrar)
                .addFileComment("AUTO-GENERATED FILE. DO NOT MODIFY.")
                .build();
        javaFile.writeTo(filer);
    }

    private String generateRegistrationId(String name) {
        name = name.replaceFirst("^TileEntity", "");
        return "tileentity_" + name.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
    }
}
